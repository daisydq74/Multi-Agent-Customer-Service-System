# Multi-Agent Customer Service System

This project runs a small multi-agent customer service demo built with FastAPI microservices plus an MCP server backed by SQLite. A router agent orchestrates requests across specialist data, support, and billing agents, while the MCP server exposes database tools the data agent can call. The stack is intentionally lightweight so you can start all services locally and watch the JSON-RPC calls flow between them.

## Components
- **MCP server (port 8000):** Provides database-backed tools for customers and tickets.
- **Data agent (port 8011):** Calls MCP tools to fetch/update customer records or assemble reports.
- **Support agent (port 8012):** Crafts empathetic replies and decides when to escalate to billing.
- **Billing agent (port 8013):** Handles escalated billing issues with concise next steps.
- **Router agent (port 8010):** Parses the incoming request, calls the data agent, and orchestrates support/billing responses.

## Quick start
```bash
pip install -r requirements.txt
python demo.py
```
`demo.py` starts all five FastAPI services, waits for their health checks, runs five sample prompts end-to-end, prints the router replies, and then shuts the services down.

- Python 3.11+ is recommended.
- If you prefer an isolated environment, create a virtualenv before installing requirements: `python -m venv .venv && source .venv/bin/activate`.
- Logs are printed to the console for every service while the demo runs so you can observe the orchestration.

## Data storage
The MCP server initializes an on-disk SQLite database (`support.db`) with sample customers and tickets on first run. No manual setup is required, but you can inspect or adjust the seed data via `database_setup.py`.

- To reseed from scratch, delete `support.db` and run `python database_setup.py`.
- You can browse the data directly with `sqlite3 support.db 'SELECT * FROM customers LIMIT 5;'` if you want to see what the agents are reading.

## Endpoints
Each service exposes a `/health` endpoint for readiness checks and a `/rpc` JSON-RPC endpoint for agent-to-agent messages. The MCP server also serves `/tools/list`, `/tools/call`, and `/events/stream` for tool metadata, execution, and event streaming respectively.

## How the demo flows
1. `demo.py` brings up the MCP server first so the data agent can immediately call its SQLite-backed tools.
2. The router receives each sample prompt on port 8010 and asks the data agent to gather context (customer lookups, ticket queries, updates).
3. Based on the data agentâ€™s findings, the router hands off to the support or billing agent to craft the final response.
4. The console output shows the final message generated by the support stack for each prompt, giving you a quick view of how cross-agent reasoning works.

## Trying your own prompts
- Start the stack with `python demo.py` and wait for the health checks to pass.
- Replace the examples inside `run_demo_queries` in `demo.py` with your own customer or billing questions.
- Alternatively, send a JSON-RPC request to `http://localhost:8010/rpc` in another terminal using `curl` or a REST client. The helper `build_request` in `demo.py` shows the expected payload shape.
